    DO ind = 1,INFrames
      RAngle = REAL(ind-1)*DEG2RADIAN*RFrameAngle
      ! Rk is the k-vector for the incident beam, which we write here in the orthogonal frame O
      Rk = RBigK*(RZDirO*COS(RAngle)+RXDirO*SIN(RAngle))
      ! Fill the list of reflections IgPoolList until we have filled the beam pool
      knd = 1  ! size of beam pool for this frame
      lnd = 1  ! size of output beam list for this frame
      DO mnd = 1,InLattice
        jnd = ISort(mnd)  ! work through reflections in ascending order
        ! Calculate Sg by getting the vector k0, which is coplanar with k and g and
        ! corresponds to an incident beam at the Bragg condition
        ! First we need the vector component of k perpendicular to g, which we call p 
        Rp = Rk - DOT_PRODUCT(Rk,RgLatticeO(jnd,:))*RgLatticeO(jnd,:)/(RLatMag(jnd)**2)
        ! and now make k0 by adding vectors parallel to g and p
        ! i.e. k0 = (p/|p|)*(k^2-g^2/4)^0.5 - g/2
        Rk0 = SQRT(RBigK**2-QUARTER*RLatMag(jnd)**2)*Rp/SQRT(DOT_PRODUCT(Rp,Rp)) - &
              HALF*RgLatticeO(jnd,:)
        ! The angle phi between k and k0 is how far we are from the Bragg condition
        Rphi = ACOS(DOT_PRODUCT(Rk,Rk0)/(RBigK**2))
        ! and now Sg is 2g sin(phi/2), with the sign of K-|K+g|
        RKplusg = Rk + RgLatticeO(jnd,:)
        RSg = TWO*RLatMag(jnd)*SIN(HALF*Rphi)*SIGN(ONE,RBigK-SQRT(DOT_PRODUCT(RKplusg,RKplusg)))
        IF (ABS(RSg).LT.RDevLimit) THEN
          IF (knd.LE.INhkl) THEN ! while the beam pool isn't full
            IgPoolList(ind,knd) = jnd  ! add it to the list
            RgPoolSg(ind,knd) = RSg  ! put Sg in its list also
            ! Is this reflection small enough to be in the output list
            IF (RLatMag(jnd).LT.RGOutLimit) THEN
              IgOutList(ind,knd) = jnd
              lnd = lnd + 1
            END IF
            knd = knd + 1
          END IF
        END IF
      END DO
    END DO





  !--------------------------------------------------------------------
  ! Start of simulation-specific calculations, depending on crystal orientation
  !--------------------------------------------------------------------
  ! frame counter
  IFrame = 1
  DO WHILE(IFrame.LE.INFrames)
!    WRITE(SPrintString, FMT='(A6,I3,A3)') "Frame ",IFrame,"..."
!    CALL message(LS,dbg3,SPrintString)
    ! Increment frame angle, if it's not the first 
    IF(IFrame.GT.1) THEN
      RXDirOn = RXDirO-RZDirO*TAN(DEG2RADIAN*RFrameAngle)
      RZDirOn = RZDirO+RXDirO*TAN(DEG2RADIAN*RFrameAngle)
      RXDirO = RXDirOn/SQRT(DOT_PRODUCT(RXDirOn,RXDirOn))
      RZDirO = RZDirOn/SQRT(DOT_PRODUCT(RZDirOn,RZDirOn))
    END IF
    ! Create reciprocal lattice vectors in Microscope reference frame
    CALL CrystalOrientation(IErr)
    IF(l_alert(IErr,"felixrefine","CrystalOrientation")) CALL abort
    !--------------------------------------------------------------------
    ! Fill the list of reflections Rhkl  ***this will be precalculated***
    Rhkl = ZERO
    RGlimit = 10.0*TWOPI    
    CALL HKLMake(RGlimit,IErr)
    IF(l_alert(IErr,"felixrefine","HKLMake")) CALL abort
    CALL message(LL,dbg7,"Rhkl matrix: ",NINT(Rhkl(1:INhkl,:)))

    !--------------------------------------------------------------------
    ! sort hkl in descending order of magnitude (not sure this is needed, really)
    CALL HKLSort(Rhkl,INhkl,IErr) 
    IF(l_alert(IErr,"felixrefine","SortHKL")) CALL abort
    ! Assign numbers to different reflections -> IhklsFrame, IhklsAll, INoOfHKLsFrame
    CALL HKLList(IFrame, IErr)
    IF(l_alert(IErr,"felixrefine","SpecificReflectionDetermination")) CALL abort
    !--------------------------------------------------------------------
    ! Now we know which reflections are in this frame
    ! allocate image arrays for pixel-parallel simulations
    ! All the individual calculations go into RSimulatedPatterns later with MPI_GATHERV
    ! NB RSimulatedPatterns is a vector with respect to pixels, not a 2D image
    ALLOCATE(RSimulatedPatterns(INoOfHKLsFrame,IThicknessCount,IPixelTotal),STAT=IErr)
    IF(l_alert(IErr,"felixrefine","allocate RSimulatedPatterns")) CALL abort
    ! Images, NB Fortan arrays are [row,column]=[y,x]
    ALLOCATE(RImageSimi(ISizeY,ISizeX,INoOfHKLsFrame,IThicknessCount),STAT=IErr)
    IF(l_alert(IErr,"felixrefine","allocate RImageSimi")) CALL abort

    !--------------------------------------------------------------------
    ! calculate g vector magnitudes and components parallel to the surface
    CALL gVectors(IErr)
    IF(l_alert(IErr,"felixrefine","gVectors")) CALL abort
    !--------------------------------------------------------------------
    ! structure factor initialization
    ! Calculate Ug matrix for each entry in CUgMatNoAbs(1:INhkl,1:INhkl)
    CALL StructureFactorInitialisation(IErr)
    IF(l_alert(IErr,"felixrefine","StructureFactorInitialisation")) CALL abort
    ! NB IEquivalentUgKey and CUniqueUg allocated in here
    ! CUniqueUg vector produced here to later fill RIndependentVariable
      
    !--------------------------------------------------------------------
    ! calculate absorptive scattering factors
    !--------------------------------------------------------------------
    CALL SYSTEM_CLOCK( IStartTime2 )
    IF(IFrame.EQ.1) CALL message(LS,dbg3,"Starting absorption calculation... ")
    CALL Absorption (IErr)
    CALL message( LM, "Initial Ug matrix, with absorption (nm^-2)" )
    DO ind = 1,6
      WRITE(SPrintString,FMT='(3(I2,1X),A2,1X,6(F7.4,1X,F7.4,2X))') NINT(Rhkl(ind,:)),": ",100*CUgMat(ind,1:6)
      CALL message( LM,dbg3, SPrintString)
    END DO
    IF(l_alert(IErr,"felixrefine","Absorption")) CALL abort
    IF(IFrame.EQ.1) THEN 
      CALL PrintEndTime(LS,IStartTime2, "Absorption" )
      CALL SYSTEM_CLOCK( IStartTime2 )
    END IF

    !--------------------------------------------------------------------
    ! set up arrays for pixel-parallel simulations
    !--------------------------------------------------------------------
    RSimulatedPatterns = ZERO
    ! The pixels to be calculated by this core  
    ILocalPixelCountMin= (IPixelTotal*(my_rank)/p)+1
    ILocalPixelCountMax= (IPixelTotal*(my_rank+1)/p) 
    ALLOCATE(RIndividualReflections(INoOfHKLsFrame,IThicknessCount,&
           (ILocalPixelCountMax-ILocalPixelCountMin)+1),STAT=IErr)
    IF(l_alert(IErr,"felixrefine","allocate RIndividualReflections")) CALL abort

    ! position of pixels calculated by this core, ILocalPixelOffset & ILocalNPix are global variables
    ALLOCATE(ILocalPixelOffset(p),ILocalNPix(p),STAT=IErr)
    IF(l_alert(IErr,"felixrefine","allocate ILocalPixelOffset")) CALL abort
    DO ind = 1,p
      ILocalPixelOffset(ind) = (IPixelTotal*(ind-1)/p)*INoOfHKLsFrame*IThicknessCount
      ILocalNPix(ind) = (((IPixelTotal*(ind)/p) - (IPixelTotal*(ind-1)/p)))* &
            INoOfHKLsFrame*IThicknessCount    
    END DO

    !--------------------------------------------------------------------
    ! simulation (different local pixels for each core)
    !--------------------------------------------------------------------
    IF(IFrame.EQ.1) CALL message(LS,"Bloch wave calculation...")    
    ! Reset simulation   
    RIndividualReflections = ZERO
    DO knd = ILocalPixelCountMin,ILocalPixelCountMax,1
      ! fills array for each pixel number knd (y & x coordinates are in IPixelLocation)
      CALL BlochCoefficientCalculation(IPixelLocation(knd,1),IPixelLocation(knd,2),knd, &
              ILocalPixelCountMin, nBeams, RThickness,RKn, IErr)
      IF(l_alert(IErr,"Simulate","BlochCoefficientCalculation")) CALL abort
    END DO
    !===================================== ! MPI gatherv into RSimulatedPatterns
    CALL MPI_GATHERV(RIndividualReflections,SIZE(RIndividualReflections),MPI_DOUBLE_PRECISION,&
         RSimulatedPatterns,ILocalNPix,ILocalPixelOffset,MPI_DOUBLE_PRECISION,&
         root,MPI_COMM_WORLD,IErr)
    !This brodcast is not strictly necessary but keeps all cores synchronised
    CALL MPI_BCAST(RIndividualReflections,SIZE(RIndividualReflections),MPI_DOUBLE_PRECISION,&
         root,MPI_COMM_WORLD,IErr)
    !=====================================
    IF(l_alert(IErr,"SimulateAndFit","MPI_GATHERV")) CALL abort
    ! put 1D array RSimulatedPatterns into 2D image RImageSimi (should be done with RESHAPE?)
    ! NB dimensions of RSimulatedPatterns(INoOfHKLsFrame,IThicknessCount,IPixelTotal)
    ! and RImageSimi(height, width, INoOfHKLsFrame,IThicknessCount )
    RImageSimi = ZERO
    lnd = 0
    DO ind = 1,ISizeY
      DO jnd = 1,ISizeX
        lnd = lnd+1
        RImageSimi(ind,jnd,:,:) = RSimulatedPatterns(:,:,lnd)
      END DO
    END DO

    ! Gaussian blur to match experiment using global variable RBlurRadius
    IF (RBlurRadius.GT.TINY) THEN
      DO ind=1,INoOfHKLsFrame
        DO jnd=1,IThicknessCount
          CALL BlurG(RImageSimi(:,:,ind,jnd),ISizeX,ISizeY,RBlurRadius,IErr)
        END DO
      END DO
    END IF

    IF(l_alert(IErr,"felixrefine","Simulate")) CALL abort
    IF(IFrame.EQ.1) CALL PrintEndTime(LS,IStartTime2, "Simulation" )

    ! output, multiple thicknesses
    IF(my_rank.EQ.0) THEN
      WRITE(SPrintString,FMT='(A24,I3,A12)') &
        "Writing simulations for ", IThicknessCount," thicknesses"
      CALL message(LL,SPrintString)
      CALL WriteIterationOutput(IErr)
      IF(l_alert(IErr,"felixrefine","WriteIterationOutput")) CALL abort 
    END IF 

    !--------------------------------------------------------------------
    ! deallocate memory used in each frame
    !--------------------------------------------------------------------
    DEALLOCATE(RSimulatedPatterns,STAT=IErr)
    DEALLOCATE(RImageSimi,STAT=IErr)
    DEALLOCATE(IEquivalentUgKey,STAT=IErr)
    DEALLOCATE(CUniqueUg,STAT=IErr)
    DEALLOCATE(RIndividualReflections,STAT=IErr)
    DEALLOCATE(ILocalPixelOffset,STAT=IErr)
    DEALLOCATE(ILocalNPix,STAT=IErr)
    !--------------------------------------------------------------------
    ! frame loop
    IFrame = IFrame + 1
  END DO
